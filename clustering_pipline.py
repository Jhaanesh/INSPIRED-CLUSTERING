# -*- coding: utf-8 -*-
"""INSPIRED_CLUSTERING_TRIAL 1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LO-V25Y5HzXpRaGuMokSaG1uQZn9oYn8

Installing the required libraries
"""

pip install pandas scipy

pip install scikit-learn pandas matplotlib

pip install seaborn

"""Importing the required packages"""

import pandas as pd #for data wrangling
from sklearn.cluster import KMeans #for clustering
import matplotlib.pyplot as plt #for plotting
from sklearn.preprocessing import StandardScaler #for scaling
from scipy.stats import skew #for skewness

import seaborn as sns #for visualisation

#Loading the dataset
data = pd.read_excel('diabetes_dataset.xlsx')
data.shape

data.isnull().sum()

#Basic statistics of the dataset
print("\nBasic statistics of the dataset:")
print(data.describe())

# Convert relevant columns to numeric, handling errors
for col in data.columns:
    if data[col].dtype == 'object':  # Check if the column is of object type (likely string)
        try:
            data[col] = pd.to_numeric(data[col], errors='coerce')  # Convert to numeric, replace non-convertibles with NaN
        except:
            print(f"Could not convert column {col} to numeric.")

#Basic statistics of the dataset
print("\nBasic statistics of the dataset:")
print(data.describe())

# Checking skewness of each feature
print("\nSkewness of each feature:")
skewness = data.apply(lambda x: skew(x.dropna()), axis=0)
print(skewness)

# Plot skewness using a bar plot
plt.figure(figsize=(12, 6))
skewness.plot(kind='bar')
plt.title('Skewness of Each Feature')
plt.xlabel('Features')
plt.ylabel('Skewness')
plt.show()

plt.figure(figsize=(15, 10))
for i, feature in enumerate(data.columns, 1):
    plt.subplot(len(data.columns) // 3 + 1, 3, i)
    sns.histplot(data[feature].dropna(), kde=True)
    plt.title(f'Distribution of {feature}')
plt.tight_layout()
plt.show()

"""Clustering the data set (K means clustering)"""



#Loading the dataset
data1 = pd.read_excel('diabetes_dataset.xlsx')
data1

data1.head()

#select the variables for clsutering
features = data1[['ageonset', 'waist', 'bmi', 'HbA1c', 'tgl', 'hdl', 'cpf', 'cps']]

# Standardize the features
scaler = StandardScaler()
scaled_features = scaler.fit_transform(features)

# Perform K-means clustering
kmeans = KMeans(n_clusters=4, max_iter=300, random_state=0)  # Choose the number of clusters (e.g., 4)
kmeans.fit(scaled_features)

# Get the cluster labels
labels = kmeans.labels_

# Add the cluster labels to the original data
data1['Cluster'] = labels

data1.head()

data1['Cluster'].value_counts()

plt.scatter(scaled_features[:, 0], scaled_features[:, 1], c=labels, cmap='viridis')
plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], s=300, c='red', label='Centroids')

# Plot clusters using seaborn pair plot
sns.pairplot(data1, vars=['ageonset', 'waist', 'bmi', 'HbA1c', 'tgl', 'hdl', 'cpf', 'cps'], hue='Cluster', palette='viridis', plot_kws={'alpha': 0.5}) # Use 'Cluster' instead of 'cluster'
plt.suptitle('Pair Plot of Features Colored by Cluster', y=1.02)
plt.show()

#Value counts and visualising the clusters
value_counts = data1['Cluster'].value_counts()
percentages =round(value_counts / value_counts.sum() * 100,1)
percentages

# Create a DataFrame for the plot
plot_data = pd.DataFrame({'Category': percentages.index, 'Percentage': percentages.values})

# Plot the percentages using seaborn
plt.figure(figsize=(10, 6))
barplot = sns.barplot(x='Category', y='Percentage', data=plot_data, palette='rocket')

# Add labels on top of the bars
for p in barplot.patches:
    barplot.annotate(format(p.get_height(), '.1f') + '%',
                     (p.get_x() + p.get_width() / 2., p.get_height()),
                     ha='center', va='center', xytext=(0, 9),
                     textcoords='offset points')

# Set the title and labels
plt.title('Percentage of Each Sub')
plt.xlabel('T2D Sub groups')
plt.ylabel('Percentage')
plt.show()

data1.head()

data1 = data1.drop(['ID', 'gender', 'diabetes', 'smoking_history'], axis=1) # Pass the labels to drop as a list and specify axis=1 to drop columns

data1

"""Summary based on clustering"""

# Calculate mean and standard deviation for each cluster
cluster_summary = data1.groupby('Cluster').agg(['mean', 'std'])

# Display the summary
print(cluster_summary)

# Round the values and format in plus/minus style
def format_plus_minus(df, decimal_places=2):
    formatted_df = df.copy()
    for column in df.columns:
        # Extract the statistic ('mean' or 'std') from the second level of the MultiIndex
        statistic = column[1]
        if statistic == 'std':
            mean_col = (column[0], 'mean')  # Construct the corresponding mean column name
            formatted_df[column] = df.apply(
                lambda row: f"{round(row[mean_col], decimal_places)} Â± {round(row[column], decimal_places)}",
                axis=1
)
    # Drop the mean columns as they are no longer needed
    formatted_df = formatted_df.drop([col for col in formatted_df.columns if 'mean' in col[1]], axis=1)
    return formatted_df

# Format the DataFrame
cluster_summary_formatted = format_plus_minus(cluster_summary)

# Transpose the DataFrame to have clusters as columns
cluster_summary_transposed = cluster_summary_formatted.T

# Display the transposed DataFrame
print(cluster_summary_transposed)

cluster_summary_transposed.to_excel('cluster_summary.xlsx', sheet_name='Summary')



"""Remvoving outliers and sub setting the data sets"""